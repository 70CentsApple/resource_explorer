package traben.resource_explorer.explorer;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.font.MultilineText;
import net.minecraft.client.texture.AbstractTexture;
import net.minecraft.client.texture.NativeImage;
import net.minecraft.client.texture.NativeImageBackedTexture;
import net.minecraft.resource.Resource;
import net.minecraft.resource.metadata.ResourceMetadata;
import net.minecraft.text.OrderedText;
import net.minecraft.text.Text;
import net.minecraft.util.Identifier;
import org.jetbrains.annotations.Nullable;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

import static traben.resource_explorer.explorer.REExplorer.outputResourceToPackInternal;

public class REResourceFile extends REResourceEntry {

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        REResourceFile that = (REResourceFile) o;
        return identifier.equals(that.identifier);
    }

    @Override
    public int hashCode() {
        return Objects.hash(identifier);
    }

    public final Identifier identifier;
    private final String displayName;
    private final OrderedText displayText;

    @Nullable
    public final Resource resource;
    public final FileType fileType;

    final AbstractTexture abstractTexture;

    public final LinkedList<String> folderStructureList;



    public static REResourceFile FAILED_FILE = new REResourceFile();
    private REResourceFile(){
        //failed file
        this.identifier = new Identifier("search_failed:fail");
        this.resource = null;
        this.abstractTexture = null;
        this.fileType = FileType.OTHER;
        displayName = "search_failed";
        folderStructureList = new LinkedList<>();
        this.displayText = Text.of("search_failed").asOrderedText();
    }

    @Override
    boolean canExport() {
        return fileType.isExportableType() && resource != null;
    }

    public REResourceFile(Identifier identifier, AbstractTexture texture){
        this.identifier = identifier;
        this.resource = null;
        this.abstractTexture = texture;
        this.fileType = FileType.getType(this.identifier);

        //split out folder hierarchy
        String[] splitDirectories = this.identifier.getPath().split("/");
        LinkedList<String> directories = new LinkedList<>(List.of(splitDirectories));

        //final entry is display file name
        displayName = directories.getLast();
        directories.removeLast();

        //remainder is folder hierarchy, which can be empty
        folderStructureList = directories;

        this.displayText = trimmedTextToWidth(displayName).asOrderedText();
    }
    public REResourceFile(Identifier identifier, @Nullable Resource resource){
        this.identifier = identifier;
        this.resource = resource;
        this.abstractTexture = null;
        this.fileType = FileType.getType(this.identifier);

        //split out folder hierarchy
        String[] splitDirectories = this.identifier.getPath().split("/");
        LinkedList<String> directories = new LinkedList<>(List.of(splitDirectories));

        //final entry is display file name
        displayName = directories.getLast();
        directories.removeLast();

        //remainder is folder hierarchy, which can be empty
        folderStructureList = directories;

        this.displayText = trimmedTextToWidth(displayName).asOrderedText();
    }


    @Override
    public String toString() {
        return toString(0);
    }

    @Override
    public String toString(int indent) {

        return " ".repeat(Math.max(0, indent)) + "\\ "+
                displayName + "\n";
    }


    @Override
    public String getDisplayName() {
        return displayName;
    }

    @Override
    OrderedText getDisplayText() {
        return displayText;
    }





    @Override
    List<Text> getExtraText(boolean smallMode) {
        ArrayList<Text> lines = new ArrayList<>();
        lines.add(trimmedTextToWidth(" type: " + fileType.toString() +(hasMetaData ? " + metadata" : "")) );
        if(resource != null) {
            lines.add(trimmedTextToWidth(" pack: " + resource.getResourcePackName().replace("file/","")));
        }else{
            lines.add(trimmedTextToWidth("§8§o generated by code" ));
        }
        if(smallMode) return lines;
        switch(fileType){
            case PNG ->{
                lines.add(trimmedTextToWidth(" height: " + height));
                lines.add(trimmedTextToWidth(" width: " + width));
                if(hasMetaData && height > width && height % width == 0) {
                    lines.add(trimmedTextToWidth(" frame count: " + (height / width)));
                }
            }
            case TXT, PROPERTIES, JSON -> {
                if(readTextByLineBreaks != null){
                    lines.add(trimmedTextToWidth(" lines: " + height));
                    lines.add(trimmedTextToWidth(" character count: " + width));
                }
            }
            case OTHER -> {
                if(readTextByLineBreaks != null){
                    lines.add(trimmedTextToWidth(""));
                    lines.add(trimmedTextToWidth(" raw text data: "));
                    lines.add(trimmedTextToWidth(" - lines: " + height));
                    lines.add(trimmedTextToWidth(" - character count: " + width));
                }
            }

            default -> {
                lines.add(trimmedTextToWidth(" //todo "));//todo
            }
        }
        return lines;
    }

    public MultilineText readTextByLineBreaks = null;

    MultilineText getTextLines(){
        if(!fileType.isRawTextType())
            return MultilineText.EMPTY;
        if(readTextByLineBreaks == null){
            if(resource!= null){
                try {
                    InputStream in = resource.getInputStream();
                    try {
                        ArrayList<Text> text = new ArrayList<>();
                        String readString = new String(in.readAllBytes(), StandardCharsets.UTF_8);
                        in.close();

                        //make tabs smaller
                        String reducedTabs = readString.replaceAll("\t"," ");


                        String[] splitByLines = reducedTabs.split("\n");

                        width = readString.length();
                        height = splitByLines.length;

                        //trim lines to width now
                        for (int i = 0; i < splitByLines.length; i++) {
                            splitByLines[i] = trimmedStringToWidth(splitByLines[i], 178);
                        }
                        int lineCount = 0;
                        for (String line:
                                splitByLines) {
                            lineCount++;
                            if(lineCount > 512){//todo set limit in config
                                text.add(Text.of("§l§4-- TEXT LONGER THAN "+512+" LINES --"));
                                text.add(Text.of("§r§o "+ (height - lineCount) +" lines skipped."));
                                text.add(Text.of("§l§4-- END --"));
                                break;
                            }
                            text.add(Text.of(line));
                        }
                        readTextByLineBreaks = MultilineText.createFromTexts(MinecraftClient.getInstance().textRenderer, text);

                    } catch (Exception e) {
                        //resource.close();
                        in.close();
                        readTextByLineBreaks = MultilineText.EMPTY;
                    }
                } catch (Exception ignored) {
                    readTextByLineBreaks = MultilineText.EMPTY;
                }
            }else{
                readTextByLineBreaks = MultilineText.create(MinecraftClient.getInstance().textRenderer, Text.of(" ERROR: no file info could be read"));
            }
        }
        return readTextByLineBreaks;
    }


    public void exportToOutputPack(REExplorer.REExportContext context) {
        boolean exported = outputResourceToPackInternal(this);
        context.tried(this, exported);
    }

    boolean imageDone = false;
    @Override
    public Identifier getIcon(boolean hovered) {

        if(fileType == FileType.PNG && hovered) {
            if(imageDone || resource == null)
                return identifier;

            imageDone = true;

            NativeImage img;
            try {
                InputStream in = resource.getInputStream();
                try {
                    img = NativeImage.read(in);
                    in.close();
                    NativeImageBackedTexture imageBackedTexture = new NativeImageBackedTexture(img);
                    MinecraftClient.getInstance().getTextureManager().registerTexture(identifier, imageBackedTexture);
                    width = img.getWidth();
                    height = img.getHeight();
                    return identifier;
                } catch (Exception e) {
                    //resource.close();
                    in.close();
                }
            } catch (Exception ignored) {}
        }
        return resource == null? REExplorer.ICON_FILE_BUILT : fileType.getDefaultIcon();
    }

    public int height = 1;
    public int width = 1;


    public REResourceFileDisplayWrapper wrapEntryAsDetailed(){
        return new REResourceFileDisplayWrapper(this);
    }
    Boolean hasMetaData = null;
    @Override
    @Nullable Identifier getIcon2OrNull(boolean hovered) {
        if(hasMetaData == null){
            if (resource != null) {
                try {
                    ResourceMetadata meta = resource.getMetadata();
                    hasMetaData = meta != null && meta != ResourceMetadata.NONE;
                } catch (IOException e) {
                    hasMetaData = false;
                }
            }else{
                hasMetaData = false;
            }
        }
        return hasMetaData ? REExplorer.ICON_HAS_META : null;
    }


    @Override
    public boolean mouseClickExplorer() {
        if(REExplorerScreen.currentDisplay != null) {
            REExplorerScreen.currentDisplay.setSelectedFile(this.wrapEntryAsDetailed());
        }
        return true;
    }

    public enum FileType {
        PNG(REExplorer.ICON_FILE_PNG),
        TXT(REExplorer.ICON_FILE_TEXT),
        JSON(REExplorer.ICON_FILE_JSON),
        PROPERTIES(REExplorer.ICON_FILE_PROPERTY),
        OGG(REExplorer.ICON_FILE_OGG),
        ZIP(REExplorer.ICON_FILE_ZIP),
        JEM(REExplorer.ICON_FILE_JEM),
        JPM(REExplorer.ICON_FILE_JEM),
        OTHER(REExplorer.ICON_FILE_UNKNOWN),
        BLANK(REExplorer.ICON_FILE_BLANK);

        public Identifier getDefaultIcon() {
            return defaultIcon;
        }

        @Override
        public String toString() {
            return switch (this){
                case PNG -> "texture";
                case TXT -> "text";
                case PROPERTIES -> "properties";
                case OGG -> "sound";
                case ZIP -> "zip folder";
                case JEM -> "CEM model";
                case JPM -> "CEM model part";
                case OTHER -> "unknown";
                case BLANK -> "";
                case JSON -> "json";
            };
        }

        public boolean isRawTextType() {
            return switch (this){
                case TXT, JSON, JPM, JEM, PROPERTIES -> true;
                default -> false;
            };
        }

        public boolean isExportableType() {
            return switch (this){
                case TXT, JSON, JPM, JEM, PROPERTIES,PNG -> true;
                default -> false;
            };
        }



        private final Identifier defaultIcon;
        FileType(Identifier defaultIcon){
            this.defaultIcon = defaultIcon;
        }

        public static FileType getType(Identifier identifier){
            String path = identifier.getPath();
            if(path.endsWith(".png")){
                return PNG;
            }
            if(path.endsWith(".json")|| path.endsWith(".json5")){
                return JSON;
            }
            if( path.endsWith(".properties") || path.endsWith(".toml")){
                return PROPERTIES;
            }
            if(path.endsWith(".jem")){
                return JEM;
            }
            if(path.endsWith(".jpm")){
                return JPM;
            }
            if(path.endsWith(".txt")){
                return TXT;
            }
            if(path.endsWith(".ogg") || path.endsWith(".mp3")){
                return OGG;
            }
            if(path.endsWith(".zip")){
                return ZIP;
            }
            return OTHER;
        }


    }


}
